/**
 * Bundle of @livelybone/date-generator
 * Generated: 2020-05-17
 * Version: 4.2.1
 * License: MIT
 * Author: 2631541504@qq.com
 */

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function fillTo(width, num) {
  var pad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';
  if (pad === undefined) pad = '0';
  num = num.toString();
  width -= num.length;

  if (width > 0) {
    return new Array(width + (/\./.test(num) ? 2 : 1)).join(pad) + num;
  }

  return num;
}
function isNonNegInt(num) {
  num = +num;
  return num === Math.floor(num) && num >= 0;
}
function objAssign(o1, o2) {
  o1 = _typeof(o1) === 'object' ? o1 : {};
  o2 = _typeof(o2) === 'object' ? o2 : {};
  return Object.keys(o1).concat(Object.keys(o2)).reduce(function (pre, k) {
    if (!(k in pre)) pre[k] = o2[k] !== undefined ? o2[k] : o1[k];
    return pre;
  }, {});
}
function positiveMod(val, div) {
  return (val % div + div) % div;
}
function isLeapYear(year) {
  year = +year;
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function getMonthLen(year, month) {
  year = +year;
  month = +month;

  if (month === 2) {
    return isLeapYear(year) ? 29 : 28;
  }

  return Math.ceil(Math.abs(month - 7.5)) % 2 === 1 ? 31 : 30;
}
function getIntervalVal(defaultMax) {
  return function (options) {
    var interval = Math.ceil(Math.abs(options && options.interval || 1));
    var min = Math.ceil(Math.abs(options && options.min || 0));
    var max = Math.ceil(Math.abs(options && options.max || defaultMax - 1));
    var arr = [];

    for (var i = 0; i <= defaultMax; i += interval) {
      arr.push({
        value: fillTo(2, i),
        max: defaultMax,
        canBeChose: i >= min && i <= max
      });
    }

    return arr;
  };
}
function parseDate(date) {
  if (!date) return null;
  var reg = /^(\d{4})-?(\d{1,2})?-?(\d{1,2})?$/;

  if (!reg.test(date)) {
    console.warn(new Error("Param date `".concat(date, "` is invalid. The right example: 2018[-02][-01]")));
    return null;
  }

  var arr = date.match(reg);
  var dateObj = {
    year: fillTo(4, arr[1]),
    month: fillTo(2, positiveMod(+arr[2] || 1, 12) || 12)
  };
  var monthLen = getMonthLen(dateObj.year, dateObj.month);
  dateObj.date = fillTo(2, positiveMod(+arr[3] || 1, monthLen) || monthLen);
  return dateObj;
}
function parseTime(time) {
  if (!time) return null;
  var reg = /^(\d{1,2}):?(\d{1,2})?:?(\d{1,2})?$/;

  if (!reg.test(time)) {
    console.warn(new Error("Param time `".concat(time, "` is invalid. The right example: 18[:02][:01]")));
    return null;
  }

  var arr = time.match(reg);
  return {
    hour: fillTo(2, positiveMod(+arr[1], 24)),
    minute: fillTo(2, positiveMod(+arr[2] || 0, 60)),
    second: fillTo(2, positiveMod(+arr[3] || 0, 60))
  };
}
function nowDate() {
  var now = new Date();
  return {
    year: fillTo(4, now.getFullYear()),
    month: fillTo(2, now.getMonth() + 1),
    date: fillTo(2, now.getDate())
  };
}
function nowTime() {
  var now = new Date();
  return {
    hour: fillTo(2, now.getHours()),
    minute: fillTo(2, now.getMinutes()),
    second: fillTo(2, now.getSeconds())
  };
}

function gntMonth(year, options) {
  year = +year;
  options = options || {};
  var splitLen = options.splitLen || 3;
  var min = typeof options.min === 'string' ? parseDate(options.min) : options.min;
  var max = typeof options.max === 'string' ? parseDate(options.max) : options.max;
  var arr = [];
  var line = Math.ceil(12 / splitLen);
  var now = nowDate();

  for (var i = 0; i < line; i += 1) {
    arr[i] = [];

    for (var j = 0; j < splitLen; j += 1) {
      var month = i * splitLen + j + 1;
      if (month > 12) break;
      arr[i].push({
        year: fillTo(4, year),
        month: fillTo(2, month),
        canBeChose: !min && !max || !!min && !!max && (year > +min.year || year === +min.year && month >= +min.month) && (year < +max.year || year === +max.year && month <= +max.month) || !max && !!min && (year > +min.year || year === +min.year && month >= +min.month) || !min && !!max && (year < +max.year || year === +max.year && month <= +max.month),
        isNow: +now.year === year && +now.month === month
      });
    }
  }

  return arr;
}
function getMonthByStep(currMonth, step) {
  var $currMonth = typeof currMonth === 'string' ? parseDate(currMonth) : currMonth;
  if (!$currMonth) return null;
  var $month = +$currMonth.month + step;
  var mod = positiveMod($month, 12);
  var times = Math.floor($month / 12);
  if (mod === 0) times -= 1;
  return {
    year: fillTo(4, +$currMonth.year + times),
    month: fillTo(2, mod || 12)
  };
}

/**
 * Integer number
 * */

/**
 * Format: /^\d\d$/
 * */
var DefaultMax;
/**
 * Format: /^(\d{4})-?(\d{1,2})?-?(\d{1,2})?$/
 * */

(function (DefaultMax) {
  DefaultMax[DefaultMax["Hour"] = 23] = "Hour";
  DefaultMax[DefaultMax["Minute"] = 59] = "Minute";
  DefaultMax[DefaultMax["Second"] = 59] = "Second";
})(DefaultMax || (DefaultMax = {}));

var DateCompare;

(function (DateCompare) {
  DateCompare[DateCompare["GreatThanYear"] = 100] = "GreatThanYear";
  DateCompare[DateCompare["GreatThanMonth"] = 10] = "GreatThanMonth";
  DateCompare[DateCompare["GreatThanDate"] = 1] = "GreatThanDate";
  DateCompare[DateCompare["Equal"] = 0] = "Equal";
  DateCompare[DateCompare["LessThanDate"] = -1] = "LessThanDate";
  DateCompare[DateCompare["LessThanMonth"] = -10] = "LessThanMonth";
  DateCompare[DateCompare["LessThanYear"] = -100] = "LessThanYear";
})(DateCompare || (DateCompare = {}));

function getDay(year, month, date) {
  year = +year;
  month = +month;
  date = +date;
  var c;
  var y;
  var m;

  if (month === 1 || month === 2) {
    c = Math.floor((year - 1) / 100);
    y = (year - 1) % 100;
    m = month + 12;
  } else {
    c = Math.floor(year / 100);
    y = year % 100;
    m = month;
  }

  return positiveMod(y + Math.floor(y / 4) + Math.floor(c / 4) - 2 * c + Math.floor(26 * (m + 1) / 10) + date - 1, 7);
}

function compareDates(date1, date2) {
  var $date1 = typeof date1 === 'string' ? parseDate(date1) : date1;
  var $date2 = typeof date2 === 'string' ? parseDate(date2) : date2;
  if (!$date1 || !$date2) return DateCompare.Equal;
  var diff = +$date1.year - +$date2.year;
  if (diff) return diff > 0 ? DateCompare.GreatThanYear : DateCompare.LessThanYear;
  diff = +$date1.month - +$date2.month;
  if (diff) return diff > 0 ? DateCompare.GreatThanMonth : DateCompare.LessThanMonth;
  diff = +$date1.date - +$date2.date;
  if (diff) return diff > 0 ? DateCompare.GreatThanDate : DateCompare.LessThanDate;
  return DateCompare.Equal;
}
function calcStepBetweenDates(date, targetDate) {
  var $date = typeof date === 'string' ? parseDate(date) : date;
  var $targetDate = typeof targetDate === 'string' ? parseDate(targetDate) : targetDate;
  if (!$date || !$targetDate) return 0;
  var compare = compareDates($date, $targetDate);
  if (compare === 0) return 0;
  var small = compare > 0 ? $targetDate : $date;
  var big = compare > 0 ? $date : $targetDate;
  var flag = compare > 0 ? 1 : -1;
  var yearStep = +big.year - +small.year;

  if (yearStep > 1) {
    return (new Array(yearStep).join(',').split('').reduce(function (pre, v, i) {
      var year = +small.year + i + 1;
      return pre + (isLeapYear(year) ? 366 : 365);
    }, 0) + calcStepBetweenDates(_objectSpread2({}, small, {
      month: 12,
      date: 31
    }), small) + calcStepBetweenDates(big, _objectSpread2({}, big, {
      month: 1,
      date: 1
    })) + 1) * flag;
  }

  if (yearStep === 1) {
    return (calcStepBetweenDates(_objectSpread2({}, small, {
      month: 12,
      date: 31
    }), small) + calcStepBetweenDates(big, _objectSpread2({}, big, {
      month: 1,
      date: 1
    })) + 1) * flag;
  }

  var monthStep = +big.month - +small.month;

  if (monthStep > 1) {
    return (new Array(monthStep).join(',').split('').reduce(function (pre, v, i) {
      var month = +small.month + i + 1;
      return pre + getMonthLen(small.year, month);
    }, 0) + calcStepBetweenDates(_objectSpread2({}, small, {
      date: getMonthLen(small.year, small.month)
    }), small) + calcStepBetweenDates(big, _objectSpread2({}, big, {
      date: 1
    })) + 1) * flag;
  }

  if (monthStep === 1) {
    return (calcStepBetweenDates(_objectSpread2({}, small, {
      date: getMonthLen(small.year, small.month)
    }), small) + calcStepBetweenDates(big, _objectSpread2({}, big, {
      date: 1
    })) + 1) * flag;
  }

  return (+big.date - +small.date) * flag;
}
function gntCalendar(monthInfo, options) {
  var $monthInfo = typeof monthInfo === 'string' ? parseDate(monthInfo) : monthInfo;
  if (!$monthInfo) return null;
  var year = +$monthInfo.year;
  var month = +$monthInfo.month;
  options = options || {};

  if (!isNonNegInt(year) || !isNonNegInt(month)) {
    throw new Error('Prop year and month must be a non-negative number');
  }

  var minD = typeof options.min === 'string' ? parseDate(options.min) : options.min;
  var maxD = typeof options.max === 'string' ? parseDate(options.max) : options.max;
  var firstDayOfWeek = options.firstDayOfWeek || 0;
  var prevMonth = getMonthByStep({
    year: year,
    month: month
  }, -1);
  var prevMonthLen = getMonthLen(prevMonth.year, prevMonth.month);
  var monthLen = getMonthLen(year, month);
  var nextMonth = getMonthByStep({
    year: year,
    month: month
  }, 1);
  var lineLen = Math.ceil(31 / 7) + 1;
  var calendar = [];

  var canChose = function canChose($year, $month, date) {
    var compare = function compare(t, flag) {
      if (!t) return true;
      flag = flag || 1;
      var y = +t.year;
      var m = +t.month;
      var d = +t.date;
      return ($year - y) * flag > 0 || $year === y && ($month - m) * flag > 0 || $year === y && $month === m && (date - d) * flag >= 0;
    };

    return compare(minD) && compare(maxD, -1);
  };

  var incrementDate = 1;
  var nextIncrementDate = 1;
  var firstDay = getDay(year, month, 1);
  var fillDateLen = (firstDay - firstDayOfWeek + 7) % 7;
  var now = nowDate();

  for (var i = 0; i < lineLen; i += 1) {
    calendar[i] = [];

    for (var j = 0; j < 7; j += 1) {
      if (i === 0 && j < fillDateLen) {
        var d = prevMonthLen - fillDateLen + 1 + j;
        calendar[i][j] = {
          year: fillTo(4, prevMonth.year),
          month: fillTo(2, prevMonth.month),
          date: fillTo(2, d),
          isInThisMonth: false,
          canBeChose: canChose(+prevMonth.year, +prevMonth.month, d),
          isNow: false
        };
        calendar[i][j].isNow = calcStepBetweenDates(now, calendar[i][j]) === 0; // eslint-disable-next-line no-continue

        continue;
      }

      if (incrementDate <= monthLen) {
        calendar[i][j] = {
          year: fillTo(4, year),
          month: fillTo(2, month),
          date: fillTo(2, incrementDate),
          isInThisMonth: true,
          canBeChose: canChose(year, month, incrementDate),
          isNow: false
        };
        calendar[i][j].isNow = calcStepBetweenDates(now, calendar[i][j]) === 0;
        incrementDate += 1;
      } else {
        calendar[i][j] = {
          year: fillTo(4, nextMonth.year),
          month: fillTo(2, nextMonth.month),
          date: fillTo(2, nextIncrementDate),
          isInThisMonth: false,
          canBeChose: canChose(+nextMonth.year, +nextMonth.month, nextIncrementDate),
          isNow: false
        };
        calendar[i][j].isNow = calcStepBetweenDates(now, calendar[i][j]) === 0;
        nextIncrementDate += 1;
      }
    }
  }

  return calendar;
}
function getDateByStep(currDate, step) {
  var $currDate = typeof currDate === 'string' ? parseDate(currDate) : currDate;
  if (!$currDate) return null;
  var len = getMonthLen($currDate.year, $currDate.month);
  var date = +$currDate.date + step;

  if (date <= 0) {
    var prevMonth = getMonthByStep($currDate, -1);
    return getDateByStep(_objectSpread2({}, prevMonth, {
      date: getMonthLen(prevMonth.year, prevMonth.month)
    }), date);
  }

  if (date > len) {
    var nextMonth = getMonthByStep($currDate, 1);
    return getDateByStep(_objectSpread2({}, nextMonth, {
      date: 1
    }), date - len);
  }

  return {
    year: fillTo(4, $currDate.year),
    month: fillTo(2, $currDate.month),
    date: fillTo(2, date)
  };
}

var getHour = getIntervalVal(DefaultMax.Hour);
var getMinute = getIntervalVal(DefaultMax.Minute);
var getSecond = getIntervalVal(DefaultMax.Second);

function gntYear(start, len, options) {
  start = +start;
  options = options || {};

  if (!isNonNegInt(+start) || !isNonNegInt(+len)) {
    throw new Error('Prop start and len must be a non-negative number');
  }

  var splitLen = options.splitLen || 3;
  var min = options.min || null;
  var max = options.max || null;
  var arr = [];
  var line = Math.ceil(len / splitLen);
  var now = nowDate();

  for (var i = 0; i < line; i += 1) {
    arr[i] = [];

    for (var j = 0; j < splitLen; j += 1) {
      var year = start + i * splitLen + j;
      if (year - start + 1 > len) break;
      arr[i].push({
        year: fillTo(4, year),
        canBeChose: !min && !max || !!min && !!max && year >= min && year <= max || !min && !!max && year <= max || !max && !!min && year >= min,
        isNow: +now.year === year
      });
    }
  }

  return arr;
}

export { DateCompare, DefaultMax, calcStepBetweenDates, compareDates, fillTo, getDateByStep, getDay, getHour, getIntervalVal, getMinute, getMonthByStep, getMonthLen, getSecond, gntCalendar, gntMonth, gntYear, isLeapYear, isNonNegInt, nowDate, nowTime, objAssign, parseDate, parseTime, positiveMod };
