/**
 * Bundle of @livelybone/copy
 * Generated: 2020-05-30
 * Version: 2.6.5
 * License: MIT
 * Author: 2631541504@qq.com
 */

/**
 * @param {Element} dom
 * @param {Object} options - Optional
 * @returns {Boolean}
 * */
function copyDom(dom, options) {
  var defaultObj = {
    clearSelect: false,
    cut: false
  };
  var opts = Object.assign({}, defaultObj, options);
  var clearSelect = opts.clearSelect,
      cut = opts.cut;
  var range;
  var selection;

  if (window.getSelection) {
    selection = window.getSelection();

    if (!selection) {
      console.error("copyDom: window.getSelection() return null");
      return false;
    }

    range = window.document.createRange();
    selection.removeAllRanges();
    range.selectNode(dom);
    selection.addRange(range);
  } else {
    // @ts-ignore
    var createTextRange = document.body.createTextRange;
    /* IE < 9 */

    if (createTextRange) {
      range = createTextRange();
      range.moveToElementText(dom);
      range.select();
    }
  }
  /* use document.execCommand `copy` */


  var success = document.execCommand('copy');
  if (selection && clearSelect) selection.removeAllRanges();

  if (cut) {
    if (dom instanceof HTMLInputElement || dom instanceof HTMLTextAreaElement) {
      dom.value = '';
    } else dom.innerHTML = '';
  }

  return success;
}

/**
 * @param {String} text
 * @return {Promise<boolean>}
 * */

function copyText(text) {
  return new Promise(function (res, rej) {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(function () {
        return res(true);
      }).catch(function (e) {
        var err = new Error(e.message ? "copyText failed, reason: ".concat(e.message) : 'copyText failed');
        rej(err);
      });
    } else {
      var textEl = document.createElement('span');
      textEl.style.position = 'fixed';
      textEl.style.left = '0';
      textEl.style.top = '0';
      textEl.style.zIndex = '-999';
      textEl.innerText = text;
      document.body.appendChild(textEl);
      var bool = copyDom(textEl);
      document.body.removeChild(textEl);
      if (bool) res(bool);else rej(new Error('copyText failed'));
    }
  });
}

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/**
 * @description If param obj is expected that can be copied
 * */
var ExpectedObjType;

(function (ExpectedObjType) {
  ExpectedObjType["NormalObj"] = "object";
  ExpectedObjType["Array"] = "Array";
})(ExpectedObjType || (ExpectedObjType = {}));

function expectedObjType(obj) {
  return _typeof(obj) === 'object' && !(obj === null || obj instanceof Promise || obj instanceof Date || obj instanceof Error || obj instanceof RegExp) && !(typeof window !== 'undefined' && (obj instanceof FileList || obj instanceof File || obj instanceof Element || obj instanceof Window || obj instanceof Document)) ? obj instanceof Array ? ExpectedObjType.Array : ExpectedObjType.NormalObj : false;
}
function newObj(target) {
  return target instanceof Array ? [] : {};
}
/**
 * @description Returns the start dimension of the nested loop
 * @param {Object} obj
 * @param {Array} tParents - Target parents
 * */

function circularStructureIndex(obj, tParents) {
  var index = Object.keys(tParents).find(function (i) {
    return tParents[+i] === obj;
  });
  return index !== undefined ? {
    index: +index
  } : undefined;
}
/**
 * @description Returns the start dimension of the nested loop
 * */

function isCircularStructure(obj) {
  var paths = ['', ''];

  var isCircular = function isCircular(object) {
    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['Object'];
    var oParents = arguments.length > 2 ? arguments[2] : undefined;
    if (_typeof(object) !== 'object' || object === null) return false;
    var parents = oParents ? [].concat(_toConsumableArray(oParents), [object]) : [object];
    return Object.entries(object).some(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      var cPath = [].concat(_toConsumableArray(path), [key]);
      var circularIndex = circularStructureIndex(value, parents);

      if (circularIndex) {
        paths[0] = cPath.slice(0, circularIndex.index + 1).reduce(function (pre, p) {
          return "".concat(pre, ".").concat(p);
        }, '').replace(/^\./, '');
        paths[1] = cPath.reduce(function (pre, p) {
          return "".concat(pre, ".").concat(p);
        }, '').replace(/^\./, '');
        return true;
      }

      return isCircular(value, cPath, parents);
    });
  };

  return isCircular(obj) ? paths : null;
}

/**
 * @description Deep copy, deal nested loop
 * @param target
 * @param {Array} tParents - Target parents
 * @param {Array} tCurParents - Current result parents
 * */

function copyFn(target, tParents, tCurParents) {
  if (expectedObjType(target)) {
    var result = newObj(target);
    var parents = tParents ? [].concat(_toConsumableArray(tParents), [target]) : [target];
    var curParents = tCurParents ? [].concat(_toConsumableArray(tCurParents), [result]) : [result];
    Object.keys(target).forEach(function (key) {
      var isCircular = circularStructureIndex(target[key], parents);

      if (isCircular) {
        result[key] = curParents[isCircular.index];
      } else {
        result[key] = copyFn(target[key], parents, curParents);
      }
    });
    return result;
  }

  return target;
}
/**
 * @description Deep copy, has the ability to deal nested loop
 * */


function objectDeepCopy(obj) {
  return copyFn(obj);
}

/**
 * @description Deep copy, cannot deal nested loop
 * */
function objectSimpleCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}

function merge(target) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  rest.forEach(function (obj) {
    Object.entries(obj).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          val = _ref2[1];

      var obj1 = target[key];

      if (expectedObjType(val) && expectedObjType(obj1)) {
        merge(obj1, val);
      } else {
        target[key] = _typeof(val) === 'object' ? objectSimpleCopy(val) : val;
      }
    });
  });
  return target;
}
/**
 * @description Deep merge, cannot deal nested loop
 * @return The first parameter object which has been merged
 * */


function objectDeepMerge(target) {
  var allTypeIs = 'same';

  for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    rest[_key2 - 1] = arguments[_key2];
  }

  var args = [target].concat(rest);
  args.forEach(function (obj, i) {
    var paths = isCircularStructure(obj);

    if (paths) {
      var pathsStr = JSON.stringify(paths);
      throw new Error("objectDeepMerge: Circular structure is not supported, the ".concat(i, "th parameter is a circular structure with CircularStructurePaths(").concat(pathsStr, ")"));
    }

    var type = expectedObjType(obj);

    if (!type || allTypeIs !== 'same' && allTypeIs !== type) {
      throw new Error('objectDeepMerge: Please ensure that parameters are all Array or normal Object');
    } else allTypeIs = type;
  });
  return merge.apply(void 0, [target].concat(rest));
}

export { copyDom, copyText, isCircularStructure, objectDeepCopy, objectDeepMerge, objectSimpleCopy };
