/**
 * Bundle of @livelybone/scroll-get
 * Generated: 2020-02-06
 * Version: 5.0.2
 * License: MIT
 * Author: 2631541504@qq.com
 */

function getRect(el) {
  return el.getBoundingClientRect();
}
function posRelativeToPage(el) {
  var o = {
    pageLeft: 0,
    pageTop: 0
  };
  var $el = el;

  while ($el) {
    o.pageLeft += $el.offsetLeft;
    o.pageTop += $el.offsetTop;
    $el = $el.offsetParent;
  }

  return o;
}
function posRelativeToClient(el) {
  var rect = getRect(el);
  return {
    clientLeft: rect.left,
    clientTop: rect.top
  };
}
/**
 * @desc if el === window || el === undefined, return the global scrollbar width info
 *       if el is an Element, return the scrollbar width info of the Element
 *
 * x: width of horizontal scrollbar
 * y: width of vertical scrollbar
 * */

function getNativeScrollbarWidth(el) {
  var $el = el || window;
  var isWindow = $el === window;

  try {
    var info = isWindow ? window.nativeScrollbarWidth : null;

    if (!(info && typeof info.y === 'number' && typeof info.x === 'number')) {
      // If nativeScrollbarWidth is illegal, reset it
      var wrapper = isWindow ? document.createElement('div') : $el;

      if (isWindow) {
        wrapper.setAttribute('style', 'position:fixed;top:0;left:0;opacity:0;pointer-events:none;width:200px;height:200px;overflow:scroll');
        document.body.appendChild(wrapper);
      }

      info = {
        y: wrapper.offsetWidth - wrapper.clientWidth,
        x: wrapper.offsetHeight - wrapper.clientHeight
      };

      if (isWindow) {
        ;
        window.nativeScrollbarWidth = info;
        document.body.removeChild(wrapper);
      }
    }

    return info;
  } catch (e) {
    // For server render
    return {
      y: 17,
      x: 17
    };
  }
}
/**
 * This affects the performance of the animation by modifying the rate
 *
 * rate >= 0 && rate <= 1
 * */

function defaultRateFactor(rate) {
  return rate + (1 - rate) * rate;
}

function animation(time, cb, rateFactor) {
  var $rateFactor = rateFactor || defaultRateFactor;

  var run = function run($cb) {
    window.requestAnimationFrame(function () {
      if ($cb()) run($cb);
    });
  };

  return new Promise(function (res) {
    var start = Date.now();
    run(function () {
      var rate = $rateFactor(Math.min(1, (Date.now() - start) / time));
      cb(rate);

      if (rate >= 1) {
        res();
        return false;
      }

      return true;
    });
  });
}
/**
 * 获取元素的可能达到的最大的 scrollTop 值
 *
 * Gets the maximum possible scrollTop value for the element
 * */

function getMaxScrollTop(el) {
  var lastChild = el.children[el.children.length - 1];

  var getStyle = function getStyle($el) {
    if ($el) {
      // @ts-ignore
      return getComputedStyle ? getComputedStyle($el) : $el.currentStyle;
    }

    return undefined;
  };

  var getMaxExceedMarginBottom = function getMaxExceedMarginBottom($el) {
    var lastMarginBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var style = getStyle($el);
    if (style && style.display === 'block') return getMaxExceedMarginBottom($el.children[$el.children.length - 1], Math.max(lastMarginBottom, parseInt(style.marginBottom, 10)));
    return lastMarginBottom;
  };

  var marginBottom = getMaxExceedMarginBottom(lastChild);
  return Math.max(0, el.scrollHeight - el.clientHeight - marginBottom);
}
/**
 * 向上遍历元素的祖先，获取第一个滚动的祖先元素
 *
 * Traverse up the ancestor of the element to get the first scrolling ancestor element
 * */

function getScrollParent($el) {
  if ($el.parentElement) {
    var scrollParent = $el.parentElement;
    if (getMaxScrollTop(scrollParent)) return scrollParent;
    return getScrollParent(scrollParent);
  }

  return undefined;
}

/**
 * @param el                The target element you want scroll to
 * @param [options]         ScrollToElementOptions
 * */
function scrollToElement(el, options) {
  var _ref = options || {},
      affectParent = _ref.affectParent,
      rateFactor = _ref.rateFactor,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? 0 : _ref$offset,
      _ref$time = _ref.time,
      time = _ref$time === void 0 ? 300 : _ref$time;

  var scrollParent = getScrollParent(el);

  if (scrollParent) {
    var parentScroll = function parentScroll() {
      return scrollToElement(scrollParent, {
        time: time,
        affectParent: affectParent,
        rateFactor: rateFactor
      });
    };

    var maxScrollTop;
    var scrollTop;

    if (scrollParent === document.body) {
      maxScrollTop = getMaxScrollTop(document.body);
      scrollTop = document.body.scrollTop;

      if (!maxScrollTop) {
        maxScrollTop = getMaxScrollTop(document.documentElement);
        scrollParent = document.documentElement;
        scrollTop = document.documentElement.scrollTop;
      }
    } else {
      maxScrollTop = getMaxScrollTop(scrollParent);
      scrollTop = scrollParent.scrollTop;
    }

    var offsetTop = getRect(el).top - getRect(scrollParent).top;
    var delta = Math.min(offsetTop + offset, maxScrollTop);

    if (delta && offsetTop && maxScrollTop > 0) {
      return animation(time, function (rate) {
        scrollParent.scrollTop = scrollTop + delta * rate;
      }, rateFactor).then(affectParent ? parentScroll : null);
    }

    if (affectParent) {
      return parentScroll();
    }
  }

  return Promise.resolve();
}
function getViewElementsWhenScroll(scrollElement, targetElements, cb) {
  if (targetElements.length > 0) {
    var oldEl = []; // 排序：比较元素位置

    targetElements.sort(function (a, b) {
      return getRect(a).top - getRect(b).top;
    });

    var scroll = function scroll(ev) {
      var scrollRect = getRect(scrollElement);
      var elementsRect = targetElements.map(getRect); // 重新计算元素当前的区域高度及可见区域高度

      var rects = elementsRect.map(function (rect, i) {
        var $rect = rect;
        $rect.areaHeight = i !== elementsRect.length - 1 ? elementsRect[i + 1].top - $rect.top : $rect.height;
        $rect.viewAreaHeight = Math.max(0, scrollRect.height + $rect.areaHeight - (Math.max($rect.top + $rect.areaHeight, scrollRect.top + scrollRect.height) - Math.min(scrollRect.top, $rect.top)));
        $rect.viewPercent = $rect.viewAreaHeight / $rect.areaHeight;
        return {
          rect: $rect,
          element: targetElements[i]
        };
      }); // 通过比较各自当前的可见区域的大小获得当前的最近元素

      var lastRect = rects[rects.length - 1];
      var viewElements = rects.sort(function (a, b) {
        return b.rect.viewPercent - a.rect.viewPercent;
      }).filter(function (el) {
        return el.rect.viewPercent > 0;
      });

      if (viewElements.length < 1) {
        lastRect.rect.viewAreaHeight = lastRect.rect.areaHeight;
        lastRect.rect.viewPercent = 1;
        viewElements = [lastRect];
      }

      if (viewElements.length !== oldEl.length || viewElements.some(function (el, i) {
        return el.element !== oldEl[i].element;
      })) {
        cb(oldEl = viewElements, scrollRect, ev);
      }
    };

    scroll();
    scrollElement.addEventListener('scroll', scroll);
    return function () {
      return scrollElement.removeEventListener('scroll', scroll);
    };
  }

  return function () {};
}

export { animation, getMaxScrollTop, getNativeScrollbarWidth, getRect, getScrollParent, getViewElementsWhenScroll, posRelativeToClient, posRelativeToPage, scrollToElement };
